--[[
Изменения script_version:
	3 - сохранение поля job_online
	5 - сохранение поля was_in_smart_terrain
	6 - сохранение поля death_droped
]]

class "se_stalker"	(cse_alife_human_stalker)

function se_stalker:__init(section) super(section)
	self.ini = nil
	self.ini_initialized = false
	self.spawner_present = false
	self.smart_terrain_conditions = nil
	self.smart_terrain_conditions_initialized = false
	self.job_online					= nil
	self.job_online_condlist = nil
	self.was_in_smart_terrain = false
	self.death_droped = false
	self.dont_spawn_online = false
	-----------------------------------
    self.s_storage                            = "_"
	-----------------------------------
end

function se_stalker:get_ini()
	if not self.ini_initialized then
		self.ini						= self:spawn_ini()
		self.ini_initialized = true

		if self.ini:section_exist("spawner") then
			self.spawner = xr_logic.parse_condlist(db.actor, "spawner", "cond", self.ini:r_string("spawner", "cond"))
		end
	end
end

function se_stalker:get_job_online()
	if self.job_online_condlist==nil then
		return self.job_online
	else
		return xr_logic.pick_section_from_condlist(db.actor_proxy, self, self.job_online)~=nil
	end
end

function se_stalker:can_switch_offline()
	if amk.convert_npc[self.id]==true then 
		return true 
	elseif amk.convert_npc[self.id]==false then	end
	if self:get_job_online()~=nil then
		return not self:get_job_online()
	else
		return cse_alife_human_stalker.can_switch_offline(self)
	end
end


function se_stalker:can_switch_online()
------------- added by DSH to avoid npc_collisions ---------------   
   if self:alive() and self:dsh_said_to_avoid_this_level() 
   then
    return false
   end
-----------------------------------------------------------------  
------------- added by Oxy to remove stalker's raid on TD during bloodsuckers quest----------------
---can't use state switching in dynamic ltx, 'cos there is currently just one state = 1 , "in raid"
--- and yes, I do know this is very crooked to do it in se_stalker... please, do better if possible.
	if 
		self.level_name == "l04_darkvalley" and self:alive() and
		self:smart_terrain_id() ~= 65535 
		and alife():object( self:smart_terrain_id() ):name() == "val_smart_bandit_1"
		and has_alife_info( "info_ecolog_mutant1_start" )
		and not has_alife_info( "info_ecolog_mutant1_done" )
	then	
	return false	
	end

---------------------------------------------------------------------------------------------------

	if amk.convert_npc[self.id]==true then 
		return false
	elseif amk.convert_npc[self.id]==false then end
	if self.dont_spawn_online==true then
		return false
	end
	if self:get_job_online()~=nil then
		return self:get_job_online()
	end
	if self.ini==nil or self.spawner==nil then
		return cse_alife_human_stalker.can_switch_online(self)
	end
	if db.actor~=nil and db.actor:alive()==false then
		return self.online
	end		
	if self.online==false then
		return(xr_logic.pick_section_from_condlist(db.actor, self, self.spawner)~=nil) and cse_alife_human_stalker.can_switch_online(self)
	else
		if xr_logic.pick_section_from_condlist(db.actor, self, self.spawner)~=nil then 
			return true
		end
		return false
	end				
end

-----------added by DSH to avoid npc_collisions------------------
-- Свободовцам через Бар ходить не надо, а долговцам через АС.
-- if
--    ( lname == "l05_bar" and self:community() == "freedom" )
--    or lname == "l07_military"
-- и Мюллеру наСвалке-Баре делать нечего, и Волкодаву

function se_stalker:dsh_said_to_avoid_this_level()
	local lname = self.level_name
	if  ( lname == "l05_bar" and self:community() == "killer" )
		or self:name() == "bar_bar_osvedomitel"
		or self:name() == "mil_dolg_stalker0000"
		or self:name() == "agr_muller"
		or ( self:name() == "esc_wolf" and lname~="l07_military" )
-- 	 	or self:profile_name() == "vasya_pupkin_profile"
		or ( ( lname == "l01_escape" and has_alife_info("tutorial_wounded_start") and not has_alife_info("tutorial_end") ) and ( self:community() == "stalker" or self:community() == "green" ) ) then
		local strn_id = self:smart_terrain_id()
		if strn_id ~= 65535 then
			local strn_sobj = alife():object( strn_id )
			if strn_sobj then
				return strn_sobj.level_name ~= lname
			end
		end
	end
	return false
end
-----------------------------------------------------------------

function se_stalker:STATE_Write(packet)
	cse_alife_human_stalker.STATE_Write(self, packet)
	if self.job_online==true then
		packet:w_u8(0)
	elseif self.job_online==false then
		packet:w_u8(1)
	elseif self.job_online==nil then
		packet:w_u8(2)
	else
		packet:w_u8(3)
		packet:w_stringZ(self.job_online_condlist)
	end
	packet:w_bool(self.was_in_smart_terrain)
	local ddw=0
	if self.death_droped then ddw=ddw+1 end
	if self.wounded then ddw=ddw+2 end
	packet:w_u8(ddw)
	-----------------------------------------
    if self.id ~= 65535 then 
        packet:w_stringZ( self.s_storage )
    end
	-----------------------------------------
end

function se_stalker:STATE_Read(packet, size)
	cse_alife_human_stalker.STATE_Read(self, packet, size)
	if self.script_version >= 3 then
		local t = packet:r_u8()
		t=bit_and(t,3)
		if t==0 then
			self.job_online = true
		elseif t==1 then
			self.job_online = false
		elseif t==2 then
			self.job_online = nil
		else
			self.job_online_condlist = packet:r_stringZ()

			self.job_online = xr_logic.parse_condlist(nil, "se_stalker:STATE_Read", "job_online", self.job_online_condlist)
		end
	end
	if self.script_version >= 5 then
		self.was_in_smart_terrain = packet:r_bool()
	end
	if self.script_version >= 6 then
		local ddw=packet:r_u8()
		self.death_droped=bit_and(ddw,1)==1
		self.wounded=bit_and(ddw,2)==2
	-----------------------------------------		
		if self.id ~= 65535 and not packet:r_eof() then    
            self.s_storage = packet:r_stringZ()            
        end    
	-----------------------------------------
	end
end

function se_stalker:on_before_register()
	self:fill_exclusives()
end

function se_stalker:on_register()
	local pk = get_netpk(self)
	local data = pk:get()
	data.dynamic_in_restrictions = {}
	pk:set(data)
	cse_alife_human_stalker.on_register(self)
	if (actor_stats.add_to_ranking~=nil)then
		local community = self:community()
		if not(community=="zombied" or
			community=="monolith")
		then
			actor_stats.add_to_ranking(self.id)
		end
	end
	task_manager.get_lua_random_task():register_target(self)
	sak_dialog.register_lua_random_npc(self)
	if self:alive() and self:smart_terrain_id()==BAD_OBJ_ID then
		self:brain():update()
	end
		alife():set_interactive( self, true )
end

function se_stalker:on_unregister()
	cse_alife_human_stalker.on_unregister(self)
	smart_terrain.unregister_npc(self)
	sak_dialog.unregister_lua_random_npc(self)
	task_manager.get_lua_random_task():unregister_target(self)
	if (actor_stats.remove_from_ranking~=nil)then
		local community = self:community()
		if community=="zombied" or
			community=="monolith"
		then
			return
		end
		actor_stats.remove_from_ranking(self.id)
	end
end

function se_stalker:on_spawn()
	cse_alife_human_stalker.on_spawn(self)

end

function se_stalker:on_death(killer)
	cse_alife_human_stalker.on_death(self, killer)

end

function se_stalker:fill_exclusives()
	self:get_ini()
	self.smart_terrain_conditions = smart_terrain.read_smart_terrain_conditions(self)
	if self.smart_terrain_conditions then
		for name, condlist in pairs(self.smart_terrain_conditions) do
			smart_terrain.exclusives[name] =(smart_terrain.exclusives[name] or 0) + 1
		end
	end
end

---------------------------------------------------------------------------------------------

class "se_trader"( cse_alife_trader )

function se_trader:__init( section ) super( section )
    self.s_storage = "_" -- добавлено из dsh-mod для торговли нпс
end

---------------------------------------------------------------------------------------------
function se_trader:STATE_Write( packet )
    cse_alife_trader.STATE_Write( self, packet )
    packet:w_stringZ( self.s_storage )
end

function se_trader:STATE_Read( packet, size )
    cse_alife_trader.STATE_Read( self, packet, size )
    if not packet:r_eof() then
        self.s_storage = packet:r_stringZ()
    end
end
---------------------------------------------------------------------------------------------

function se_trader:keep_saved_data_anyway()
	return true
end